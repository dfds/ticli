/*
SelfService API

SelfService API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// KafkaTopicAPIService KafkaTopicAPI service
type KafkaTopicAPIService service

type ApiKafkatopicsGetRequest struct {
	ctx context.Context
	ApiService *KafkaTopicAPIService
	capabilityId *string
	clusterId *string
	includePrivate *bool
}

func (r ApiKafkatopicsGetRequest) CapabilityId(capabilityId string) ApiKafkatopicsGetRequest {
	r.capabilityId = &capabilityId
	return r
}

func (r ApiKafkatopicsGetRequest) ClusterId(clusterId string) ApiKafkatopicsGetRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiKafkatopicsGetRequest) IncludePrivate(includePrivate bool) ApiKafkatopicsGetRequest {
	r.includePrivate = &includePrivate
	return r
}

func (r ApiKafkatopicsGetRequest) Execute() (*KafkaTopicListApiResource, *http.Response, error) {
	return r.ApiService.KafkatopicsGetExecute(r)
}

/*
KafkatopicsGet Method for KafkatopicsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKafkatopicsGetRequest
*/
func (a *KafkaTopicAPIService) KafkatopicsGet(ctx context.Context) ApiKafkatopicsGetRequest {
	return ApiKafkatopicsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KafkaTopicListApiResource
func (a *KafkaTopicAPIService) KafkatopicsGetExecute(r ApiKafkatopicsGetRequest) (*KafkaTopicListApiResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KafkaTopicListApiResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KafkaTopicAPIService.KafkatopicsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafkatopics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.capabilityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "CapabilityId", r.capabilityId, "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ClusterId", r.clusterId, "")
	}
	if r.includePrivate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludePrivate", r.includePrivate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKafkatopicsIdConsumersGetRequest struct {
	ctx context.Context
	ApiService *KafkaTopicAPIService
	id string
}

func (r ApiKafkatopicsIdConsumersGetRequest) Execute() (*KafkaTopicApiResource, *http.Response, error) {
	return r.ApiService.KafkatopicsIdConsumersGetExecute(r)
}

/*
KafkatopicsIdConsumersGet Method for KafkatopicsIdConsumersGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiKafkatopicsIdConsumersGetRequest
*/
func (a *KafkaTopicAPIService) KafkatopicsIdConsumersGet(ctx context.Context, id string) ApiKafkatopicsIdConsumersGetRequest {
	return ApiKafkatopicsIdConsumersGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return KafkaTopicApiResource
func (a *KafkaTopicAPIService) KafkatopicsIdConsumersGetExecute(r ApiKafkatopicsIdConsumersGetRequest) (*KafkaTopicApiResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KafkaTopicApiResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KafkaTopicAPIService.KafkatopicsIdConsumersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafkatopics/{id}/consumers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKafkatopicsIdDeleteRequest struct {
	ctx context.Context
	ApiService *KafkaTopicAPIService
	id string
}

func (r ApiKafkatopicsIdDeleteRequest) Execute() (*KafkaTopicApiResource, *http.Response, error) {
	return r.ApiService.KafkatopicsIdDeleteExecute(r)
}

/*
KafkatopicsIdDelete Method for KafkatopicsIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiKafkatopicsIdDeleteRequest
*/
func (a *KafkaTopicAPIService) KafkatopicsIdDelete(ctx context.Context, id string) ApiKafkatopicsIdDeleteRequest {
	return ApiKafkatopicsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return KafkaTopicApiResource
func (a *KafkaTopicAPIService) KafkatopicsIdDeleteExecute(r ApiKafkatopicsIdDeleteRequest) (*KafkaTopicApiResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KafkaTopicApiResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KafkaTopicAPIService.KafkatopicsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafkatopics/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKafkatopicsIdDescriptionPutRequest struct {
	ctx context.Context
	ApiService *KafkaTopicAPIService
	id string
	changeKafkaTopicDescriptionRequest *ChangeKafkaTopicDescriptionRequest
}

func (r ApiKafkatopicsIdDescriptionPutRequest) ChangeKafkaTopicDescriptionRequest(changeKafkaTopicDescriptionRequest ChangeKafkaTopicDescriptionRequest) ApiKafkatopicsIdDescriptionPutRequest {
	r.changeKafkaTopicDescriptionRequest = &changeKafkaTopicDescriptionRequest
	return r
}

func (r ApiKafkatopicsIdDescriptionPutRequest) Execute() (*KafkaTopicApiResource, *http.Response, error) {
	return r.ApiService.KafkatopicsIdDescriptionPutExecute(r)
}

/*
KafkatopicsIdDescriptionPut Method for KafkatopicsIdDescriptionPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiKafkatopicsIdDescriptionPutRequest
*/
func (a *KafkaTopicAPIService) KafkatopicsIdDescriptionPut(ctx context.Context, id string) ApiKafkatopicsIdDescriptionPutRequest {
	return ApiKafkatopicsIdDescriptionPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return KafkaTopicApiResource
func (a *KafkaTopicAPIService) KafkatopicsIdDescriptionPutExecute(r ApiKafkatopicsIdDescriptionPutRequest) (*KafkaTopicApiResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KafkaTopicApiResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KafkaTopicAPIService.KafkatopicsIdDescriptionPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafkatopics/{id}/description"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.changeKafkaTopicDescriptionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKafkatopicsIdGetRequest struct {
	ctx context.Context
	ApiService *KafkaTopicAPIService
	id string
}

func (r ApiKafkatopicsIdGetRequest) Execute() (*KafkaTopicApiResource, *http.Response, error) {
	return r.ApiService.KafkatopicsIdGetExecute(r)
}

/*
KafkatopicsIdGet Method for KafkatopicsIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiKafkatopicsIdGetRequest
*/
func (a *KafkaTopicAPIService) KafkatopicsIdGet(ctx context.Context, id string) ApiKafkatopicsIdGetRequest {
	return ApiKafkatopicsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return KafkaTopicApiResource
func (a *KafkaTopicAPIService) KafkatopicsIdGetExecute(r ApiKafkatopicsIdGetRequest) (*KafkaTopicApiResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KafkaTopicApiResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KafkaTopicAPIService.KafkatopicsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafkatopics/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKafkatopicsIdMessagecontractsContractIdGetRequest struct {
	ctx context.Context
	ApiService *KafkaTopicAPIService
	id string
	contractId string
}

func (r ApiKafkatopicsIdMessagecontractsContractIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.KafkatopicsIdMessagecontractsContractIdGetExecute(r)
}

/*
KafkatopicsIdMessagecontractsContractIdGet Method for KafkatopicsIdMessagecontractsContractIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param contractId
 @return ApiKafkatopicsIdMessagecontractsContractIdGetRequest
*/
func (a *KafkaTopicAPIService) KafkatopicsIdMessagecontractsContractIdGet(ctx context.Context, id string, contractId string) ApiKafkatopicsIdMessagecontractsContractIdGetRequest {
	return ApiKafkatopicsIdMessagecontractsContractIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		contractId: contractId,
	}
}

// Execute executes the request
func (a *KafkaTopicAPIService) KafkatopicsIdMessagecontractsContractIdGetExecute(r ApiKafkatopicsIdMessagecontractsContractIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KafkaTopicAPIService.KafkatopicsIdMessagecontractsContractIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafkatopics/{id}/messagecontracts/{contractId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiKafkatopicsIdMessagecontractsContractIdRetryPostRequest struct {
	ctx context.Context
	ApiService *KafkaTopicAPIService
	id string
	contractId string
}

func (r ApiKafkatopicsIdMessagecontractsContractIdRetryPostRequest) Execute() (*KafkaTopicApiResource, *http.Response, error) {
	return r.ApiService.KafkatopicsIdMessagecontractsContractIdRetryPostExecute(r)
}

/*
KafkatopicsIdMessagecontractsContractIdRetryPost Method for KafkatopicsIdMessagecontractsContractIdRetryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param contractId
 @return ApiKafkatopicsIdMessagecontractsContractIdRetryPostRequest
*/
func (a *KafkaTopicAPIService) KafkatopicsIdMessagecontractsContractIdRetryPost(ctx context.Context, id string, contractId string) ApiKafkatopicsIdMessagecontractsContractIdRetryPostRequest {
	return ApiKafkatopicsIdMessagecontractsContractIdRetryPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return KafkaTopicApiResource
func (a *KafkaTopicAPIService) KafkatopicsIdMessagecontractsContractIdRetryPostExecute(r ApiKafkatopicsIdMessagecontractsContractIdRetryPostRequest) (*KafkaTopicApiResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KafkaTopicApiResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KafkaTopicAPIService.KafkatopicsIdMessagecontractsContractIdRetryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafkatopics/{id}/messagecontracts/{contractId}/retry"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKafkatopicsIdMessagecontractsGetRequest struct {
	ctx context.Context
	ApiService *KafkaTopicAPIService
	id string
}

func (r ApiKafkatopicsIdMessagecontractsGetRequest) Execute() (*KafkaTopicApiResource, *http.Response, error) {
	return r.ApiService.KafkatopicsIdMessagecontractsGetExecute(r)
}

/*
KafkatopicsIdMessagecontractsGet Method for KafkatopicsIdMessagecontractsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiKafkatopicsIdMessagecontractsGetRequest
*/
func (a *KafkaTopicAPIService) KafkatopicsIdMessagecontractsGet(ctx context.Context, id string) ApiKafkatopicsIdMessagecontractsGetRequest {
	return ApiKafkatopicsIdMessagecontractsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return KafkaTopicApiResource
func (a *KafkaTopicAPIService) KafkatopicsIdMessagecontractsGetExecute(r ApiKafkatopicsIdMessagecontractsGetRequest) (*KafkaTopicApiResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KafkaTopicApiResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KafkaTopicAPIService.KafkatopicsIdMessagecontractsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafkatopics/{id}/messagecontracts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKafkatopicsIdMessagecontractsPostRequest struct {
	ctx context.Context
	ApiService *KafkaTopicAPIService
	id string
	newMessageContractRequest *NewMessageContractRequest
}

func (r ApiKafkatopicsIdMessagecontractsPostRequest) NewMessageContractRequest(newMessageContractRequest NewMessageContractRequest) ApiKafkatopicsIdMessagecontractsPostRequest {
	r.newMessageContractRequest = &newMessageContractRequest
	return r
}

func (r ApiKafkatopicsIdMessagecontractsPostRequest) Execute() (*KafkaTopicApiResource, *http.Response, error) {
	return r.ApiService.KafkatopicsIdMessagecontractsPostExecute(r)
}

/*
KafkatopicsIdMessagecontractsPost Method for KafkatopicsIdMessagecontractsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiKafkatopicsIdMessagecontractsPostRequest
*/
func (a *KafkaTopicAPIService) KafkatopicsIdMessagecontractsPost(ctx context.Context, id string) ApiKafkatopicsIdMessagecontractsPostRequest {
	return ApiKafkatopicsIdMessagecontractsPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return KafkaTopicApiResource
func (a *KafkaTopicAPIService) KafkatopicsIdMessagecontractsPostExecute(r ApiKafkatopicsIdMessagecontractsPostRequest) (*KafkaTopicApiResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KafkaTopicApiResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KafkaTopicAPIService.KafkatopicsIdMessagecontractsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafkatopics/{id}/messagecontracts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newMessageContractRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKafkatopicsIdMessagecontractsValidatePostRequest struct {
	ctx context.Context
	ApiService *KafkaTopicAPIService
	id string
	validateMessageContractRequest *ValidateMessageContractRequest
}

func (r ApiKafkatopicsIdMessagecontractsValidatePostRequest) ValidateMessageContractRequest(validateMessageContractRequest ValidateMessageContractRequest) ApiKafkatopicsIdMessagecontractsValidatePostRequest {
	r.validateMessageContractRequest = &validateMessageContractRequest
	return r
}

func (r ApiKafkatopicsIdMessagecontractsValidatePostRequest) Execute() (*KafkaTopicApiResource, *http.Response, error) {
	return r.ApiService.KafkatopicsIdMessagecontractsValidatePostExecute(r)
}

/*
KafkatopicsIdMessagecontractsValidatePost Method for KafkatopicsIdMessagecontractsValidatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiKafkatopicsIdMessagecontractsValidatePostRequest
*/
func (a *KafkaTopicAPIService) KafkatopicsIdMessagecontractsValidatePost(ctx context.Context, id string) ApiKafkatopicsIdMessagecontractsValidatePostRequest {
	return ApiKafkatopicsIdMessagecontractsValidatePostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return KafkaTopicApiResource
func (a *KafkaTopicAPIService) KafkatopicsIdMessagecontractsValidatePostExecute(r ApiKafkatopicsIdMessagecontractsValidatePostRequest) (*KafkaTopicApiResource, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KafkaTopicApiResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KafkaTopicAPIService.KafkatopicsIdMessagecontractsValidatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kafkatopics/{id}/messagecontracts-validate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validateMessageContractRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
